#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        FPGA_DS.py
## 
## Project :     AAVS Tango FPGA Driver
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      andrea.demarco$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""A Tango device server for the FPGA board."""

__all__ = ["FPGA_DS", "FPGA_DSClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
# ----- PROTECTED REGION ID(FPGA_DS.additionnal_import) ENABLED START -----#
from PyTango import DevState, Util, Attr, SpectrumAttr, Attribute, MultiAttribute
from PyTango._PyTango import DevFailed, DevFailed
from pyfabil import Device, BoardState
from types import *
import pickle
import inspect
# ----- PROTECTED REGION END -----#	//	FPGA_DS.additionnal_import

## Device States Description
## ON : Device is ON for alarm/event handling.
## ALARM : Device is ALARM for alarm/event handling.

class FPGA_DS (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    # ----- PROTECTED REGION ID(FPGA_DS.global_variables) ENABLED START -----#
    all_states_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    plugin_cmd_list = {}
    plugin_state_list = {}

    # State flow definitions - allowed states for each command
    state_list = {
        'add_command': all_states_list,
        'connect': all_states_list,
        'create_scalar_attribute': all_states_list,
        'create_vector_attribute': all_states_list,
        'disconnect': all_states_list,
        'flush_attributes': all_states_list,
        'generate_attributes': all_states_list,
        'get_device_list': all_states_list,
        'get_firmware_list': all_states_list,
        'get_register_info': all_states_list,
        'get_register_list': all_states_list,
        'load_firmware': all_states_list,
        'load_plugin': all_states_list,
        'unload_plugin': all_states_list,
        'unload_all_plugins': all_states_list,
        'read_address': all_states_list,
        'read_device': all_states_list,
        'read_register': all_states_list,
        'remove_command': all_states_list,
        'run_plugin_command': all_states_list,
        'set_attribute_levels': all_states_list,
        'set_board_state': all_states_list,
        'write_address': all_states_list,
        'write_device': all_states_list,
        'write_register': all_states_list,
        'reset_board': all_states_list,
        'update_plugins': all_states_list,
        'sink_alarm_state': all_states_list
    }

    def call_plugin_command(self, argin=None):
        """ This method is responsible for calling a command from attached plugins.
        The input to this command has to include a set of arguments required by the command to be called.

        :param argin: A pickled dictionary with required arguments.
        :type: PyTango.DevString
        :return:
            Any output of the called command.
            An empty dictionary is returned for commands with no returned values.
        :rtype: PyTango.DevString """
        self.debug_stream("In call_plugin_command()")
        argout = None

        arguments = pickle.loads(argin)
        command_name = arguments['fnName']
        arginput = arguments['fnInput']

        if command_name in self.plugin_cmd_list:
            self.info_stream("Called existent command: %s" % command_name)
            state_ok = self.check_state_flow_plugin(command_name)
            if state_ok:
                try:
                    argin_dict = pickle.loads(arginput)
                    # self.info_stream("Input to command: %s" % argin_dict)
                    if argin_dict:
                        self.info_stream("Call with parameters")
                        argout = eval('self.fpga_instance.%s' % command_name(arginput))

                        # command_trace = command_name.split('.')
                        # argout = getattr(getattr(self.fpga_instance, command_trace[0]), command_trace[1])(arginput)
                    else:
                        self.info_stream("Call without parameters")
                        argout = eval('self.fpga_instance.%s' % command_name())

                        # command_trace = command_name.split('.')
                        # a = 'tpm_adc[0].initliase(asdflkasjdk)'
                        # res = eval('self.fpga_instance.%s' % a)
                        # getattr(self.fpga_instance, command_name[0])

                        # argout = getattr(getattr(self.fpga_instance, command_trace[0]), command_trace[1])()
                except DevFailed as df:
                    self.info_stream("Failed to run plugin command: %s" % df)
                    argout = ''
            else:
                self.debug_stream("Invalid state")
        else:
            self.debug_stream("Called non-existent command")
        return argout

    def check_state_flow(self, fnName):
        """ Checks if the current state the device is in one of the states in a given list of allowed states for a paticular function.
        :param : Name of command to be executed
        :type: String
        :return: True if allowed, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In check_state_flow() for %s" % fnName)
        argout = False
        # get allowed states for this command
        try:
            fnAllowedStates = self.state_list[fnName]
            allowed = self.attr_board_state_read in fnAllowedStates
            argout = allowed
            if allowed:
                self.debug_stream("Permission verified.")
            else:
                self.debug_stream("Permission denied.")
        except DevFailed as df:
            self.info_stream("Failed to check state flow: %s" % df)
            argout = False
        finally:
            return argout

    def check_state_flow_plugin(self, fnName):
        """ Checks if the current state the device is in one of the states in a given list of allowed states for a paticular function.
        :param : Name of command to be executed
        :type: String
        :return: True if allowed, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In check_state_flow() for %s" % fnName)
        argout = False
        # get allowed states for this command
        try:
            fnAllowedStates = self.plugin_state_list[fnName]
            allowed = self.attr_board_state_read in fnAllowedStates
            argout = allowed
            if allowed:
                self.debug_stream("Permission verified.")
            else:
                self.debug_stream("Permission denied.")
        except DevFailed as df:
            self.info_stream("Failed to check state flow: %s" % df)
            argout = False
        finally:
            return argout

    def get_device(self, name):
        """ Extract device name from provided register name, if present """
        try:
            device = name.split('.')[0].upper()
            if device == "BOARD":
                return Device.Board
            elif device == "FPGA1":
                return Device.FPGA_1
            elif device == "FPGA2":
                return Device.FPGA_2
            elif device == "FPGA3":
                return Device.FPGA_3
            elif device == "FPGA4":
                return Device.FPGA_4
            elif device == "FPGA5":
                return Device.FPGA_5
            elif device == "FPGA6":
                return Device.FPGA_6
            elif device == "FPGA7":
                return Device.FPGA_7
            elif device == "FPGA8":
                return Device.FPGA_8
            else:
                return None
        except:
            return None

    def read_general_scalar(self, attr):
        """ A method that reads from a scalar attribute.

        :param attr: The attribute to read from.
        :type: PyTango.DevAttr
        :return: The read data.
        :rtype: PyTango.DevULong """
        self.debug_stream("Reading attribute %s", attr.get_name())
        arguments = {}
        dev = self.get_device(attr.get_name())
        arguments['device'] = dev.value
        arguments['register'] = attr.get_name()
        arguments['words'] = 1
        arguments['offset'] = 0
        args = str(arguments)
        values_array = self.read_register(args)  # get actual value by reading from register
        attr.set_value(values_array[0])  # readRegister returns an array, so a scalar requires a read from 0'th location

    def write_general_scalar(self, attr):
        """ A method that writes to a scalar attribute.

        :param attr: The attribute to write to.
        :type: PyTango.DevAttr
        :return: Success or failure.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("Writing attribute %s", attr.get_name())
        data = attr.get_write_value()
        arguments = {}
        dev = self.get_device(attr.get_name())
        arguments['device'] = dev.value
        arguments['register'] = attr.get_name()
        arguments['offset'] = 0
        arguments['values'] = data
        args = str(arguments)
        self.write_register(args)

    def read_general_vector(self, attr):
        """ A method that reads from a scalar attribute.

        :param attr: The attribute to read from.
        :type: PyTango.DevAttr
        :return: The read data.
        :rtype: PyTango.DevVarULongArray """
        self.debug_stream("Reading attribute %s", attr.get_name())
        arguments = {}
        dev = self.get_device(attr.get_name())
        arguments['device'] = dev.value
        arguments['register'] = attr.get_name()
        arguments['words'] = 1
        arguments['offset'] = 0
        args = str(arguments)
        values_array = self.read_register(args)  # get actual values by reading from register
        attr.set_value(values_array)  # readRegister returns an array

    def write_general_vector(self, attr):
        """ A method that writes to a vector attribute.

        :param attr: The attribute to write to.
        :type: PyTango.DevAttr
        :return: Success or failure.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("Writting attribute %s", attr.get_name())
        data = attr.get_write_value()
        arguments = {}
        dev = self.get_device(attr.get_name())
        arguments['device'] = dev.value
        arguments['register'] = attr.get_name()
        arguments['offset'] = 0
        arguments['values'] = data
        args = str(arguments)
        self.write_register(args)

    # ----- PROTECTED REGION END -----#	//	FPGA_DS.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        FPGA_DS.init_device(self)
        # ----- PROTECTED REGION ID(FPGA_DS.__init__) ENABLED START -----#
        # self.fpga_instance = None
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        # ----- PROTECTED REGION ID(FPGA_DS.delete_device) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_board_state_read = 0
        self.attr_is_programmed_read = False
        self.attr_ip_address_read = ''
        self.attr_port_read = 0
        self.attr_is_connected_read = False
        # ----- PROTECTED REGION ID(FPGA_DS.init_device) ENABLED START -----#
        self.info_stream("Starting device initialization...")
        self.set_state(DevState.ON)
        self.set_board_state(BoardState.Init.value)
        self.fpga_instance = []
        self.info_stream("Device has been initialized.")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        # ----- PROTECTED REGION ID(FPGA_DS.always_executed_hook) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.always_executed_hook

    #-----------------------------------------------------------------------------
    #    FPGA_DS read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_board_state(self, attr):
        self.debug_stream("In read_board_state()")
        # ----- PROTECTED REGION ID(FPGA_DS.board_state_read) ENABLED START -----#
        attr.set_value(self.attr_board_state_read)
        self.info_stream(BoardState(self.attr_board_state_read))
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.board_state_read
        
    def read_is_programmed(self, attr):
        self.debug_stream("In read_is_programmed()")
        # ----- PROTECTED REGION ID(FPGA_DS.is_programmed_read) ENABLED START -----#
        attr.set_value(self.attr_is_programmed_read)

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.is_programmed_read
        
    def read_ip_address(self, attr):
        self.debug_stream("In read_ip_address()")
        # ----- PROTECTED REGION ID(FPGA_DS.ip_address_read) ENABLED START -----#
        attr.set_value(self.attr_ip_address_read)
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.ip_address_read
        
    def write_ip_address(self, attr):
        self.debug_stream("In write_ip_address()")
        data=attr.get_write_value()
        # ----- PROTECTED REGION ID(FPGA_DS.ip_address_write) ENABLED START -----#
        self.info_stream("IP Address set up.")
        self.attr_ip_address_read = data
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.ip_address_write
        
    def read_port(self, attr):
        self.debug_stream("In read_port()")
        # ----- PROTECTED REGION ID(FPGA_DS.port_read) ENABLED START -----#
        attr.set_value(self.attr_port_read)
        # self.info_stream("Attribute: %s has quality: %s" %(attr.get_name(), attr.get_quality()))
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.port_read
        
    def write_port(self, attr):
        self.debug_stream("In write_port()")
        data=attr.get_write_value()
        # ----- PROTECTED REGION ID(FPGA_DS.port_write) ENABLED START -----#
        # self.info_stream("Port set up.")
        self.attr_port_read = data
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.port_write
        
    def read_is_connected(self, attr):
        self.debug_stream("In read_is_connected()")
        #----- PROTECTED REGION ID(FPGA_DS.is_connected_read) ENABLED START -----#
        attr.set_value(self.attr_is_connected_read)
        #----- PROTECTED REGION END -----#	//	FPGA_DS.is_connected_read
        
    def write_is_connected(self, attr):
        self.debug_stream("In write_is_connected()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FPGA_DS.is_connected_write) ENABLED START -----#
        self.attr_is_connected_read = data
        #----- PROTECTED REGION END -----#	//	FPGA_DS.is_connected_write
        
    
    
        # ----- PROTECTED REGION ID(FPGA_DS.initialize_dynamic_attributes) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        # ----- PROTECTED REGION ID(FPGA_DS.read_attr_hardware) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    FPGA_DS command methods
    #-----------------------------------------------------------------------------
    
    def add_command(self, argin):
        """ A generic command that adds a new command entry to the Tango device driver.
        
        :param argin: A string containing a dictionary for fields required for command creation.
        :type: PyTango.DevString
        :return: True if command creation was successful, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In add_command()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.add_command) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        # state_ok = self.check_state_flow(self.add_command.__name__)
        if state_ok:
            #  Protect the script from exceptions raised by Tango
            try:
                # Try create a new command entry
                self.debug_stream("Unpacking arguments...")
                arguments = pickle.loads(argin)
                commandName = arguments['commandName']
                inDesc = arguments['inDesc']
                outDesc = arguments['outDesc']
                allowedStates = arguments['states']
                self.plugin_state_list[commandName] = allowedStates
                self.plugin_cmd_list[commandName] = [[PyTango.DevString, inDesc], [PyTango.DevString, outDesc]]
                # self.cmd_list[commandName] = [[PyTango.DevString, inDesc], [PyTango.DevString, outDesc]]
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to create new command entry in device server: \n%s" % df)
                argout = False
            finally:
                return argout
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.add_command
        return argout
        
    def connect(self):
        """ Opens the connection to the device.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In connect()")
        # ----- PROTECTED REGION ID(FPGA_DS.connect) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.info_stream("Connecting...")
                self.fpga_instance.connect(self.attr_ip_address_read, self.attr_port_read)
                self.info_stream("Connected to board.")
                self.attr_is_connected_read = True
                self.info_stream("Setting up plugins...")
                self.update_plugins()
                self.info_stream("Plugins ready.")
            except DevFailed as df:
                self.debug_stream("Failed to connect: %s" % df)
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.connect
        
    def create_scalar_attribute(self, argin):
        """ A method that creates a new scalar attribute.
        
        :param argin: New attribute name.
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In create_scalar_attribute()")
        # ----- PROTECTED REGION ID(FPGA_DS.create_scalar_attribute) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                attr = Attr(argin, PyTango.DevULong)
                self.info_stream("Creating new scalar attribute: %s" % argin)
                self.add_attribute(attr, self.read_general_scalar, self.write_general_scalar)
                self.info_stream("Scalar attribute created")
            except DevFailed as df:
                self.debug_stream("Failed to create scalar attribute: %s" % df)
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.create_scalar_attribute
        
    def create_vector_attribute(self, argin):
        """ A method that creates a new vector attribute.
        
        :param argin: New attribute name.
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In create_vector_attribute()")
        # ----- PROTECTED REGION ID(FPGA_DS.create_vector_attribute) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.debug_stream("Unpacking arguments...")
                arguments = pickle.loads(argin)
                name = arguments['name']
                length = arguments['length']

                attr = SpectrumAttr(name, PyTango.DevULong, PyTango.READ_WRITE, length)
                self.info_stream("Creating new vector attribute: %s" % name)
                self.add_attribute(attr, self.read_general_vector, self.write_general_vector)
                self.info_stream("Vector attribute created")
            except DevFailed as df:
                self.debug_stream("Failed to create vector attribute: %s" % df)
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.create_vector_attribute
        
    def disconnect(self):
        """ Disconnect this device.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In disconnect()")
        # ----- PROTECTED REGION ID(FPGA_DS.disconnect) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.info_stream("Disconnecting...")
            self.fpga_instance.disconnect()
            self.info_stream("Disconnected from board.")
            self.attr_is_connected_read = False
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.disconnect
        
    def flush_attributes(self):
        """ A method that removes all attributes for the current firmware.
        
        :param : 
        :type: PyTango.DevVoid
        :return: Returns True if command was successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In flush_attributes()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.flush_attributes) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                if self.attr_is_programmed_read:
                    register_dict = self.fpga_instance.get_register_list()
                    if not register_dict:  # if dict is empty
                        for reg_name, entries in register_dict.iteritems():
                            self.remove_attribute(reg_name)
                    argout = True
                else:
                    self.info_stream("Device not programmed. No attributes removed.")
            except DevFailed as df:
                self.debug_stream("Failed to flush attributes: %s" % df)
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.flush_attributes
        return argout
        
    def generate_attributes(self):
        """ A method that generates dynamic attributes based on the current firmware.
        
        :param : 
        :type: PyTango.DevVoid
        :return: Returns True if command was successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In generate_attributes()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.generate_attributes) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        self.flush_attributes()
        if state_ok:
            register_dict = self.fpga_instance.get_register_list()
            try:
                for reg_name, entries in register_dict.iteritems():
                    size = entries.get('size')
                    # print reg_name, size
                    if size > 1:
                        self.info_stream("Setting up a new vector attribute...")
                        args = {'name': reg_name, 'length': size}
                        self.create_vector_attribute(pickle.dumps(args))
                        self.info_stream("Name: %s - Size: %s" % (reg_name, size))
                    else:
                        self.info_stream("Setting up a new scalar attribute...")
                        self.create_scalar_attribute(reg_name)
                        self.info_stream("Name: %s - Size: %s" % (reg_name, 1))
                argout = True
            except DevFailed as df:
                self.debug_stream("Firmware attribute generation failed for: %s - Error: %s" % (reg_name, df))
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.generate_attributes
        return argout
        
    def get_device_list(self):
        """ Returns a list of devices, as a serialized python dictionary, stored as a string.
        
        :param : 
        :type: PyTango.DevVoid
        :return: Dictionary of devices.
        :rtype: PyTango.DevString """
        self.debug_stream("In get_device_list()")
        argout = ''
        # ----- PROTECTED REGION ID(FPGA_DS.get_device_list) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.info_stream("Retrieving device list...")
                devlist = self.fpga_instance.get_device_list()
                argout = pickle.dumps(devlist)
                self.info_stream("Device list retrieved.")
            except DevFailed as df:
                self.debug_stream("Failed to get device list: %s" % df)
                argout = ''
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.get_device_list
        return argout
        
    def get_firmware_list(self, argin):
        """ Returns a list of firmwares, as a serialized python dictionary, stored as a string.
        
        :param argin: Device on board to get list of firmware, as a string.
        :type: PyTango.DevString
        :return: Dictionary of firmwares on the board.
        :rtype: PyTango.DevString """
        self.debug_stream("In get_firmware_list()")
        argout = ''
        # ----- PROTECTED REGION ID(FPGA_DS.get_firmware_list) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.debug_stream("Unpacking arguments...")
                arguments = pickle.loads(argin)
                device = arguments['device']

                if device is not None:
                    self.info_stream("Retrieving firmware list...")
                    firmware_list = self.fpga_instance.get_firmware_list(Device(device))
                    argout = pickle.dumps(firmware_list)
                    self.info_stream("Firmware list retreived.")
                else:
                    self.info_stream("No device supplied. Retrieval terminated.")
                    argout = pickle.dumps('')
            except DevFailed as df:
                self.debug_stream("Failed to get firmware list: %s" % df)
                argout = pickle.dumps('')
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.get_firmware_list
        return argout
        
    def get_register_info(self, argin):
        """ Gets a dictionary of information associated with a specified register.
        
        :param argin: The register name for which information will be retrieved.
        :type: PyTango.DevString
        :return: Returns a string-encoded dictionary of information.
        :rtype: PyTango.DevString """
        self.debug_stream("In get_register_info()")
        argout = ''
        # ----- PROTECTED REGION ID(FPGA_DS.get_register_info) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.info_stream("Retrieving register info...")
                arguments = {}
                arguments['reset'] = False
                arguments['load_values'] = False
                args = pickle.dumps(arguments)

                reglist = self.fpga_instance.get_register_list(args)
                value = reglist.get(argin)
                argout = pickle.dumps(value)
                self.info_stream("Register info retrieved.")
            except DevFailed as df:
                self.debug_stream("Failed to get register info: %s" % df)
                argout = ''
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.get_register_info
        return argout
        
    def get_register_list(self, argin):
        """ Returns a list of registers and values, as a serialized python dictionary, stored as a string.
        
        :param argin: Dictionary with arguments.
        :type: PyTango.DevString
        :return: List of register names.
        :rtype: PyTango.DevVarStringArray """
        self.debug_stream("In get_register_list()")
        argout = ['']
        # ----- PROTECTED REGION ID(FPGA_DS.get_register_list) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        self.debug_stream("Permission: %s" % state_ok)
        if state_ok:
            try:
                self.debug_stream("Unpacking arguments...")
                arguments = pickle.loads(argin)
                reset = arguments['reset']
                load_values = arguments['load_values']

                self.debug_stream("Checking argument values...")
                if reset is None:
                    reset = False
                if load_values is None:
                    load_values = False

                self.info_stream("Retrieving register list...")
                register_dict = self.fpga_instance.get_register_list(reset=reset, load_values=load_values)
                argout = register_dict.keys()
                self.info_stream("Register list retrieved.")
            except DevFailed as df:
                self.debug_stream("Failed to get register list: %s" % df)
                argout = ''
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.get_register_list
        return argout
        
    def load_firmware(self, argin):
        """ Call to load firmware.
        
        :param argin: File path.
        :type: PyTango.DevString
        :return: Return true if successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In load_firmware()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.load_firmware) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            device = arguments['device']
            filepath = arguments['path']
            load_values = arguments['load_values']

            self.debug_stream("Checking argument values...")
            if load_values is None:
                load_values = False

            self.flush_attributes()
            try:
                self.fpga_instance.load_firmware(Device(device), filepath=filepath, load_values=load_values)
                self.generate_attributes()
                self.attr_is_programmed_read = True
                self.info_stream("Firmware loaded.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to load firmware: %s" % df)
                self.attr_is_programmed_read = False
                self.flush_attributes()
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.load_firmware
        return argout
        
    def load_plugin(self, argin):
        """ Loads a plugin in device server.
        
        :param argin: Name of plugin. Case sensitive.
        :type: PyTango.DevString
        :return: Return True if successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In load_plugin()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.load_plugin) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            plugin_list = self.fpga_instance.get_available_plugins()
            #self.info_stream("List of plugins: %s" % plugin_list)
            class_names = plugin_list.keys()
            #self.info_stream("List of plugins class names: %s" % class_names)
            friendly_names = plugin_list.values()
            # self.info_stream("Plugins: %s" % class_names)

            # unpack plugin name and kwargs
            arguments = pickle.loads(argin)
            plugin_name_load = arguments['plugin_name_load']
            kw_args = arguments['kw_args']

            plugin_list = self.fpga_instance.get_available_plugins()
            class_names = plugin_list.keys()
            friendly_names = plugin_list.values()

            plugin_index = friendly_names.index(plugin_name_load)
            plugin_class_name = class_names[plugin_index]
            plugin_friendly_name = friendly_names[plugin_index]

            try:
                self.fpga_instance.load_plugin(plugin_class_name, **kw_args)
                self.update_plugins()
                argout = True
                self.info_stream("Plugin load: %s" % argout)
            except DevFailed as df:
                self.debug_stream("Failed to load plugin: %s" % df)
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.load_plugin
        return argout
        
    def read_address(self, argin):
        """ Reads values from a register location. Instead of a register name, the actual physical address has to be provided.
        
        :param argin: Associated register information.
        :type: PyTango.DevString
        :return: Register values.
        :rtype: PyTango.DevVarULongArray """
        self.debug_stream("In read_address()")
        argout = [0]
        # ----- PROTECTED REGION ID(FPGA_DS.read_address) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            address = arguments['address']
            words = arguments['words']

            self.debug_stream("Checking argument values...")
            if words is None:
                words = 1

            self.info_stream("Reading address...")
            try:
                pass_address = eval(address)
                result = self.fpga_instance.read_address(pass_address, n=words)
                self.info_stream("Address read.")
                if words > 1:
                    argout = result
                else:
                    argout = [result]
            except DevFailed as df:
                self.debug_stream("Failed to read address: %s" % df)
                argout = []
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = []
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.read_address
        return argout
        
    def read_device(self, argin):
        """ Get device value.
        
        :param argin: 
            String containing:
            1) SPI Device to read from
            2) Address on device to read from
        :type: PyTango.DevString
        :return: Value of device.
        :rtype: PyTango.DevULong """
        self.debug_stream("In read_device()")
        argout = 0
        # ----- PROTECTED REGION ID(FPGA_DS.read_device) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            device = arguments['device']
            address = arguments['address']

            self.info_stream("Reading device...")
            try:
                pass_address = eval(address)
                argout = self.fpga_instance.read_device(device, pass_address)
                self.info_stream("Device read.")
            except DevFailed as df:
                self.debug_stream("Failed to read device: %s" % df)
                argout = 0
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = 0
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.read_device
        return argout
        
    def read_register(self, argin):
        """ Reads values from a register location.
        
        :param argin: Associated register information.
        :type: PyTango.DevString
        :return: Register values.
        :rtype: PyTango.DevVarULongArray """
        self.debug_stream("In read_register()")
        argout = [0]
        # ----- PROTECTED REGION ID(FPGA_DS.read_register) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            device = arguments['device']
            register = arguments['register']
            words = arguments['words']
            offset = arguments['offset']

            self.debug_stream("Checking argument values...")
            if words is None:
                words = 1
            if offset is None:
                offset = 0

            reg_info = pickle.loads(self.get_register_info(register))
            try:
                length_register = reg_info['size']
                if words + offset <= length_register:
                    self.debug_stream("Register: %s" % register)
                    self.debug_stream("Words: %s" % words)
                    self.debug_stream("Offset: %s" % offset)
                    self.debug_stream("Device: %s" % device)
                    self.info_stream("Reading register...")
                    result = self.fpga_instance.read_register(register, n=words, offset=offset, device=Device(device))

                    if words > 1:
                        argout = result
                    else:
                        argout = [result]
                    self.info_stream("Register read.")
                else:
                    self.info_stream("Register size limit exceeded, no values read.")
            except DevFailed as df:
                self.debug_stream("Failed to read register: %s" % df)
                argout = []
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = []
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.read_register
        return argout
        
    def run_plugin_command(self, argin):
        """ Proxy to run a particular plugin command.
        
        :param argin: Dictionary with name of command to run, and arguments.
        :type: PyTango.DevString
        :return: Any output from the command.
        :rtype: PyTango.DevString """
        self.debug_stream("In run_plugin_command()")
        argout = ''
        # ----- PROTECTED REGION ID(FPGA_DS.run_plugin_command) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            fnName = arguments['fnName']
            fnInput = arguments['fnInput']

            if fnName in self.plugin_cmd_list:
                self.info_stream("About to run arbitrary command: %s" % fnName)
                methodCalled = getattr(self, fnName)
                self.info_stream("Calling method: %s" % methodCalled)
                try:
                    argout = methodCalled(argin)
                    argout = pickle.dumps(argout)
                    self.info_stream("Arbitrary command completed.")
                except DevFailed as df:
                    self.debug_stream("Failed to run plugin command: %s" % df)
                    argout = ''
                finally:
                    return argout
            else:
                self.info_stream("Command does not exist.")
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.run_plugin_command
        return argout
        
    def set_attribute_levels(self, argin):
        """ Set alarm levels for a particular attribute.
        1) min_value : (str) minimum allowed value
        2 )max_value : (str) maximum allowed value
        3) min_alarm : (str) low alarm level
        4) max_alarm : (str) high alarm level
        
        :param argin: A pickled string storing a dictionary with the required alarm levels, and name of attribute.
        :type: PyTango.DevString
        :return: Returns True if command was successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In set_attribute_levels()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.set_attribute_levels) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            attr_name = arguments.get('name')
            min_value = arguments.get('min_value')
            max_value = arguments.get('max_value')
            min_alarm = arguments.get('min_alarm')
            max_alarm = arguments.get('max_alarm')

            multi_attr = self.get_device_attr()
            attribute = multi_attr.get_attr_by_name(attr_name)
            multi_prop = attribute.get_properties()
            multi_prop.min_value = min_value
            multi_prop.max_value = max_value
            multi_prop.min_alarm = min_alarm
            multi_prop.max_alarm = max_alarm
            try:
                self.info_stream("Setting attribute levels...")
                attribute.set_properties(multi_prop)
                self.info_stream("Attribute levels set.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to set attribute levels: %s" % df)
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.set_attribute_levels
        return argout
        
    def set_board_state(self, argin):
        """ Sets the board status by passing in a value.
                UNKNOWN	=  0
                INIT		=  1
                ON		=  2
                RUNNING	=  3
                FAULT		=  4
                OFF		=  5
                STANDBY	=  6
                SHUTTING_DOWN	=  7
                MAINTENANCE	=  8
                LOW_POWER	=  9
                SAFE_STATE	=  10
        
        :param argin: Board status value.
        :type: PyTango.DevLong
        :return: Returns True if command successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In set_board_state()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.set_board_state) ENABLED START -----#
        if argin in self.all_states_list:
            self.info_stream("Setting board state...")
            self.attr_board_state_read = argin
            self.info_stream("Board state set.")
            argout = True
        else:
            self.info_stream("Wrong state given. Expected one of: %s" % self.all_states_list)

    # def write_address(self, argin):
    #     """ Writes values to a register location. The actual physical address has to be provided.
    #
    #     :param argin: Associated register information.
    #     :type: PyTango.DevString
    #     :return: True if successful, false if not.
    #     :rtype: PyTango.DevBoolean """
    #     self.debug_stream("In write_address()")
    #     argout = False
    #     #----- PROTECTED REGION ID(FPGA_DS.write_address) ENABLED START -----#
    #     state_ok = self.check_state_flow(self.write_address.__name__)
    #     if state_ok:
    #         arguments = pickle.loads(argin)
    #         address = arguments['address']
    #         values = arguments['values']
    #         argout = self.fpga_instance.write_address(address, values)
    #     else:
    #         self.debug_stream("Invalid state")
    #     #----- PROTECTED REGION END -----#	//	FPGA_DS.write_address
        return argout
        
    def write_address(self, argin):
        """ Writes values to a register location. The actual physical address has to be provided.
        
        :param argin: Associated register information.
        :type: PyTango.DevString
        :return: True if successful, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In write_address()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.write_address) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            address = arguments['address']
            values = arguments['values']

            try:
                self.info_stream("Writing address...")
                pass_address = eval(address)
                argout = self.fpga_instance.write_address(address=pass_address, values=values)
                self.info_stream("Address written.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to write address: %s" % df)
                argout = False
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = False
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.write_address
        return argout
        
    def write_device(self, argin):
        """ Set device value.
        
        :param argin: 
            A string containing the following:
            1) SPI device to write to
            2) Address on device to write to
            3) Value to write
        :type: PyTango.DevString
        :return: True if successful, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In write_device()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.write_device) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            device = arguments['device']
            address = arguments['address']
            value = arguments['value']

            try:
                self.info_stream("Writing device...")
                pass_address = eval(address)
                argout = self.fpga_instance.write_device(device=device, address=pass_address, value=value)
                self.info_stream("Device written.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to write device: %s" % df)
                argout = False
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = False
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.write_device
        return argout
        
    def write_register(self, argin):
        """ Writes values from a register location.
        
        :param argin: Associated register information.
        :type: PyTango.DevString
        :return: True if successful, false if not.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In write_register()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.write_register) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            device = arguments['device']
            register = arguments['register']
            values = arguments['values']
            offset = arguments['offset']

            self.debug_stream("Checking argument values...")
            if offset is None:
                offset = 0

            reg_info = pickle.loads(self.get_register_info(register))
            try:
                length_register = reg_info['size']
                length_values = len(values)
                if length_values + offset <= length_register:
                    self.info_stream("Writing register...")
                    argout = self.fpga_instance.write_register(register, values, offset=offset, device=Device(device))
                    argout = True
                    self.info_stream("Register written.")
                else:
                    self.info_stream("Register size limit exceeded, no changes committed.")
            except DevFailed as df:
                self.debug_stream("Failed to write register: %s" % df)
                argout = False
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = False
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.write_register
        return argout
        
    def sink_alarm_state(self):
        """ This method is designed to turn off the device alarm state. It however, the cause that triggers an alarm is still present, alarm will turn back on.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In sink_alarm_state()")
        # ----- PROTECTED REGION ID(FPGA_DS.sink_alarm_state) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.info_stream("Resetting alarms...")
                self.set_state(DevState.ON)
                self.info_stream("Alarms reset.")
            except DevFailed as df:
                self.debug_stream("Failed to reset board: %s" % df)
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
        else:
            self.debug_stream("Invalid state")
            # ----- PROTECTED REGION END -----#	//	FPGA_DS.sink_alarm_state
        
    def unload_plugin(self, argin):
        """ This command removes a plugin if it is loaded.
        
        :param argin: Plugin name to unload.
        :type: PyTango.DevString
        :return: True if successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In unload_plugin()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.unload_plugin) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.debug_stream("Unpacking arguments...")
            arguments = pickle.loads(argin)
            plugin = arguments['plugin']
            instance = arguments['instance']

            plugin_list = self.fpga_instance.get_available_plugins()
            class_names = plugin_list.keys()
            friendly_names = plugin_list.values()

            plugin_index = friendly_names.index(plugin)
            plugin_class_name = class_names[plugin_index]
            plugin_friendly_name = friendly_names[plugin_index]


            plugin_name_unload = plugin_friendly_name
            self.info_stream("Plugin to remove: %s" % plugin_name_unload)

            if plugin_name_unload in friendly_names:
                try:
                    if instance is None:
                        self.fpga_instance.unload_plugin(plugin_friendly_name)
                    else:
                        self.fpga_instance.unload_plugin(plugin_friendly_name, instance=instance)

                    self.info_stream("Plugin removed.")
                    self.update_plugins()
                    argout = True
                except DevFailed as df:
                    self.debug_stream("Failed to unload plugin: %s" % df)
                    argout = False
                except:
                    self.debug_stream("Unexpected error: %s" % sys.exc_info()[0])
                    argout = False
            else:
                self.info_stream("Plugin not found.")
                argout = False
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.unload_plugin
        return argout
        
    def reset_board(self, argin):
        """ A command to reset the board.
        
        :param argin: Input arguments as dictionary pickled in a string.
        :type: PyTango.DevString
        :return: Returns true if successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In reset_board()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.reset_board) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.debug_stream("Unpacking arguments...")
                arguments = pickle.loads(argin)
                device = arguments['device']

                self.info_stream("Resetting board...")
                self.fpga_instance.reset(device=Device(device))
                self.info_stream("Board reset.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to reset board: %s" % df)
                argout = False
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
                argout = False
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.reset_board
        return argout
        
    def unload_all_plugins(self):
        """ A command to unload all plugins and instances.
        
        :param : 
        :type: PyTango.DevVoid
        :return: True if operation successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In unload_all_plugins()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.unload_all_plugins) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            self.info_stream("Cleaning up...")
            self.fpga_instance.unload_all_plugins()
            self.update_plugins()
            self.info_stream("All plugins removed.")
            argout = True
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.unload_all_plugins
        return argout
        
    def update_plugins(self):
        """ This command is used to sync the Tango driver with the internal plugin state of the access layer.
        
        :param : 
        :type: PyTango.DevVoid
        :return: Returns true of update was successful.
        :rtype: PyTango.DevBoolean """
        self.debug_stream("In update_plugins()")
        argout = False
        # ----- PROTECTED REGION ID(FPGA_DS.update_plugins) ENABLED START -----#
        state_ok = self.check_state_flow(inspect.stack()[0][3])
        if state_ok:
            try:
                self.info_stream("Updating plugins...")
                self.plugin_cmd_list = {}
                self.plugin_state_list = {}

                self.info_stream("Old registry removed. Rebuilding...")
                plugins_dict = self.fpga_instance.get_loaded_plugins()  # friendly name

                for plugin_friendly_name in plugins_dict:
                    # Find how many instances of this plugin exist
                    plugin_instances = 0
                    if self.fpga_instance.__dict__:
                        plugin_instances = len(getattr(self.fpga_instance, plugin_friendly_name))

                    # for every instance
                    for i in range(1, plugin_instances):
                        for command in plugins_dict[plugin_friendly_name]:
                            full_command_name = plugin_friendly_name + '[' + str(i - 1) + ']' + '.' + command
                            self.info_stream("Adding commands: %s" % full_command_name)
                            arguments = {}
                            arguments['commandName'] = full_command_name
                            arguments['inDesc'] = ''
                            arguments['outDesc'] = ''
                            arguments['states'] = self.all_states_list
                            args = pickle.dumps(arguments)
                            result = self.add_command(args)
                            if result == True:
                                self.info_stream("Command [%s].[%s] created successfully in device server." % (
                                    plugin_friendly_name, full_command_name))
                                try:
                                    self.__dict__[full_command_name] = lambda input: self.call_plugin_command(input)
                                except DevFailed as df:
                                    self.debug_stream("Failed to create lambda expression: %s" % df)
                                    self.info_stream("Command [%s].[%s] not created" % full_command_name)
                            else:
                                self.info_stream("Command [%s].[%s] not created" % full_command_name)

                self.info_stream("Plugins updated.")
                argout = True
            except DevFailed as df:
                self.debug_stream("Failed to update plugins: %s" % df)
            except:
                self.debug_stream("Unexpected error. Operation ignored. Maybe inputs are incorrect?")
        else:
            self.debug_stream("Invalid state")
        # ----- PROTECTED REGION END -----#	//	FPGA_DS.update_plugins
        return argout
        

    # ----- PROTECTED REGION ID(FPGA_DS.programmer_methods) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.programmer_methods

class FPGA_DSClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    # ----- PROTECTED REGION ID(FPGA_DS.global_class_variables) ENABLED START -----#

    # ----- PROTECTED REGION END -----#	//	FPGA_DS.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`FPGA_DS.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        # ----- PROTECTED REGION ID(FPGA_DS.dyn_attr) ENABLED START -----#

                # ----- PROTECTED REGION END -----#	//	FPGA_DS.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        }


    #    Command definitions
    cmd_list = {
        'add_command':
            [[PyTango.DevString, "A string containing a dictionary for fields required for command creation."],
            [PyTango.DevBoolean, "True if command creation was successful, false if not."]],
        'connect':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'create_scalar_attribute':
            [[PyTango.DevString, "New attribute name."],
            [PyTango.DevVoid, "none"]],
        'create_vector_attribute':
            [[PyTango.DevString, "New attribute name."],
            [PyTango.DevVoid, "none"]],
        'disconnect':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'flush_attributes':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "Returns True if command was successful."]],
        'generate_attributes':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "Returns True if command was successful."]],
        'get_device_list':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevString, "Dictionary of devices."]],
        'get_firmware_list':
            [[PyTango.DevString, "Device on board to get list of firmware, as a string."],
            [PyTango.DevString, "Dictionary of firmwares on the board."]],
        'get_register_info':
            [[PyTango.DevString, "The register name for which information will be retrieved."],
            [PyTango.DevString, "Returns a string-encoded dictionary of information."]],
        'get_register_list':
            [[PyTango.DevString, "Dictionary with arguments."],
            [PyTango.DevVarStringArray, "List of register names."]],
        'load_firmware':
            [[PyTango.DevString, "File path."],
            [PyTango.DevBoolean, "Return true if successful."]],
        'load_plugin':
            [[PyTango.DevString, "Name of plugin. Case sensitive."],
            [PyTango.DevBoolean, "Return True if successful."]],
        'read_address':
            [[PyTango.DevString, "Associated register information."],
            [PyTango.DevVarULongArray, "Register values."]],
        'read_device':
            [[PyTango.DevString, "String containing:\n1) SPI Device to read from\n2) Address on device to read from"],
            [PyTango.DevULong, "Value of device."]],
        'read_register':
            [[PyTango.DevString, "Associated register information."],
            [PyTango.DevVarULongArray, "Register values."]],
        'run_plugin_command':
            [[PyTango.DevString, "Dictionary with name of command to run, and arguments."],
            [PyTango.DevString, "Any output from the command."]],
        'set_attribute_levels':
            [[PyTango.DevString, "A pickled string storing a dictionary with the required alarm levels, and name of attribute."],
            [PyTango.DevBoolean, "Returns True if command was successful."]],
        'set_board_state':
            [[PyTango.DevLong, "Board status value."],
            [PyTango.DevBoolean, "Returns True if command successful."]],
        'write_address':
            [[PyTango.DevString, "Associated register information."],
            [PyTango.DevBoolean, "True if successful, false if not."]],
        'write_device':
            [[PyTango.DevString, "A string containing the following:\n1) SPI device to write to\n2) Address on device to write to\n3) Value to write"],
            [PyTango.DevBoolean, "True if successful, false if not."]],
        'write_register':
            [[PyTango.DevString, "Associated register information."],
            [PyTango.DevBoolean, "True if successful, false if not."]],
        'sink_alarm_state':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'unload_plugin':
            [[PyTango.DevString, "Plugin name to unload."],
            [PyTango.DevBoolean, "True if successful."]],
        'reset_board':
            [[PyTango.DevString, "Input arguments as dictionary pickled in a string."],
            [PyTango.DevBoolean, "Returns true if successful."]],
        'unload_all_plugins':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "True if operation successful."]],
        'update_plugins':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevBoolean, "Returns true of update was successful."]],
        }


    #    Attribute definitions
    attr_list = {
        'board_state':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ]],
        'is_programmed':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ]],
        'ip_address':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE]],
        'port':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ_WRITE]],
        'is_connected':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE]],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(FPGA_DSClass,FPGA_DS,'FPGA_DS')
        # ----- PROTECTED REGION ID(FPGA_DS.add_classes) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	FPGA_DS.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
